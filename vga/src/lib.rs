//! From libvga.c, LSE Epita
#![feature(min_const_fn)]
#![cfg_attr(feature = "no_std", no_std)]

extern crate i386;

use core::ptr::NonNull;

use i386::instructions;

type Port = instructions::Port<u8>;

const VGA_AC_INDEX: u16 = 0x3C0;
const VGA_AC_WRITE: u16 = 0x3C0;
const VGA_AC_READ: u16 = 0x3C1;
const VGA_MISC_WRITE: u16 = 0x3C2;
const VGA_SEQ_INDEX: u16 = 0x3C4;
const VGA_SEQ_DATA: u16 = 0x3C5;
const VGA_DAC_MASK: u16 = 0x3C6;
const VGA_DAC_READ_INDEX: u16 = 0x3C7;
const VGA_DAC_WRITE_INDEX: u16 = 0x3C8;
const VGA_DAC_DATA: u16 = 0x3C9;
const VGA_MISC_READ: u16 = 0x3CC;
const VGA_GC_INDEX: u16 = 0x3CE;
const VGA_GC_DATA: u16 = 0x3CF;

const VGA_CRTC_INDEX: u16 = 0x3D4;
const VGA_CRTC_DATA: u16 = 0x3D5;
const VGA_INSTAT_READ: u16 = 0x3DA;

const VGA_NUM_SEQ_REGS: usize = 5;
const VGA_NUM_CRTC_REGS: usize = 25;
const VGA_NUM_GC_REGS: usize = 9;
const VGA_NUM_AC_REGS: usize = 21;

/// Basic Windows BITMAP pallet;
const DEFAULT_PALETTE: [u32; 256] = [
    0x0, 0x800000, 0x8000, 0x808000, 0x80, 0x800080, 0x8080, 0xc0c0c0, 0xc0dcc0, 0xa6caf0,
    0x402000, 0x602000, 0x802000, 0xa02000, 0xc02000, 0xe02000, 0x4000, 0x204000, 0x404000,
    0x604000, 0x804000, 0xa04000, 0xc04000, 0xe04000, 0x6000, 0x206000, 0x406000, 0x606000,
    0x806000, 0xa06000, 0xc06000, 0xe06000, 0x8000, 0x208000, 0x408000, 0x608000, 0x808000,
    0xa08000, 0xc08000, 0xe08000, 0xa000, 0x20a000, 0x40a000, 0x60a000, 0x80a000, 0xa0a000,
    0xc0a000, 0xe0a000, 0xc000, 0x20c000, 0x40c000, 0x60c000, 0x80c000, 0xa0c000, 0xc0c000,
    0xe0c000, 0xe000, 0x20e000, 0x40e000, 0x60e000, 0x80e000, 0xa0e000, 0xc0e000, 0xe0e000, 0x40,
    0x200040, 0x400040, 0x600040, 0x800040, 0xa00040, 0xc00040, 0xe00040, 0x2040, 0x202040,
    0x402040, 0x602040, 0x802040, 0xa02040, 0xc02040, 0xe02040, 0x4040, 0x204040, 0x404040,
    0x604040, 0x804040, 0xa04040, 0xc04040, 0xe04040, 0x6040, 0x206040, 0x406040, 0x606040,
    0x806040, 0xa06040, 0xc06040, 0xe06040, 0x8040, 0x208040, 0x408040, 0x608040, 0x808040,
    0xa08040, 0xc08040, 0xe08040, 0xa040, 0x20a040, 0x40a040, 0x60a040, 0x80a040, 0xa0a040,
    0xc0a040, 0xe0a040, 0xc040, 0x20c040, 0x40c040, 0x60c040, 0x80c040, 0xa0c040, 0xc0c040,
    0xe0c040, 0xe040, 0x20e040, 0x40e040, 0x60e040, 0x80e040, 0xa0e040, 0xc0e040, 0xe0e040, 0x80,
    0x200080, 0x400080, 0x600080, 0x800080, 0xa00080, 0xc00080, 0xe00080, 0x2080, 0x202080,
    0x402080, 0x602080, 0x802080, 0xa02080, 0xc02080, 0xe02080, 0x4080, 0x204080, 0x404080,
    0x604080, 0x804080, 0xa04080, 0xc04080, 0xe04080, 0x6080, 0x206080, 0x406080, 0x606080,
    0x806080, 0xa06080, 0xc06080, 0xe06080, 0x8080, 0x208080, 0x408080, 0x608080, 0x808080,
    0xa08080, 0xc08080, 0xe08080, 0xa080, 0x20a080, 0x40a080, 0x60a080, 0x80a080, 0xa0a080,
    0xc0a080, 0xe0a080, 0xc080, 0x20c080, 0x40c080, 0x60c080, 0x80c080, 0xa0c080, 0xc0c080,
    0xe0c080, 0xe080, 0x20e080, 0x40e080, 0x60e080, 0x80e080, 0xa0e080, 0xc0e080, 0xe0e080, 0xc0,
    0x2000c0, 0x4000c0, 0x6000c0, 0x8000c0, 0xa000c0, 0xc000c0, 0xe000c0, 0x20c0, 0x2020c0,
    0x4020c0, 0x6020c0, 0x8020c0, 0xa020c0, 0xc020c0, 0xe020c0, 0x40c0, 0x2040c0, 0x4040c0,
    0x6040c0, 0x8040c0, 0xa040c0, 0xc040c0, 0xe040c0, 0x60c0, 0x2060c0, 0x4060c0, 0x6060c0,
    0x8060c0, 0xa060c0, 0xc060c0, 0xe060c0, 0x80c0, 0x2080c0, 0x4080c0, 0x6080c0, 0x8080c0,
    0xa080c0, 0xc080c0, 0xe080c0, 0xa0c0, 0x20a0c0, 0x40a0c0, 0x60a0c0, 0x80a0c0, 0xa0a0c0,
    0xc0a0c0, 0xe0a0c0, 0xc0c0, 0x20c0c0, 0x40c0c0, 0x60c0c0, 0x80c0c0, 0xa0c0c0, 0xfffbf0,
    0xa0a0a4, 0x808080, 0xff0000, 0xff00, 0xffff00, 0xff, 0xff00ff, 0xffff, 0xffffff,
];

static mut TEXT_MODE_FONT: [u8; 320 * 200] = [0; 320 * 200];
static mut GRAPHIC_REGS: Regs = Regs::graphic_regs();
static mut TEXT_REGS: Regs = Regs::text_regs();

pub fn switch_mode13h() {
    unsafe { write_regs(&mut GRAPHIC_REGS) };

    // Save plane 2
    if let Some(vram) = get_framebuffer() {
        for (i, c) in unsafe { TEXT_MODE_FONT.iter_mut() }.enumerate() {
            *c = unsafe { *vram.as_ptr().add(i) };
        }
    }
}

pub fn switch_mode3h() {
    // Restore plane 2
    if let Some(vram) = get_framebuffer() {
        for (i, &c) in unsafe { TEXT_MODE_FONT }.iter().enumerate() {
            unsafe { *vram.as_ptr().add(i) = c };
        }
    }

    unsafe { write_regs(&mut TEXT_REGS) };
}

pub unsafe fn set_palette(palette: &[u32]) {
    Port::new(VGA_DAC_WRITE_INDEX).write(0);
    let mut dac_data_port = Port::new(VGA_DAC_DATA);
    for color in palette {
        dac_data_port.write(((((color >> 16) >> 2) as u32) & 0xFF) as u8);
        dac_data_port.write(((((color >> 8) >> 2) as u32) & 0xFF) as u8);
        dac_data_port.write((((color >> 2) as u32) & 0xFF) as u8);
    }
}

pub fn get_framebuffer() -> Option<NonNull<u8>> {
    unsafe { Port::new(VGA_GC_INDEX).write(6) };
    let mmap_select = (unsafe { Port::new(VGA_GC_DATA).read() } >> 2) & 0b11;
    NonNull::new(match mmap_select {
        0 | 1 => 0xA0000,
        2 => 0xB0000,
        3 => 0xB8000,
        _ => 0,
    } as *mut u8)
}

unsafe fn write_regs(regs: &mut Regs) {
    // Write MISC
    Port::new(VGA_MISC_WRITE).write(regs.misc);

    // Write SEQ
    for (i, &seq) in regs.seq.iter().enumerate() {
        Port::new(VGA_SEQ_INDEX).write(i as u8);
        Port::new(VGA_SEQ_DATA).write(seq);
    }

    // Write CRTC
    let mut crtc_index_port = Port::new(VGA_CRTC_INDEX);
    let mut crtc_data_port = Port::new(VGA_CRTC_DATA);

    crtc_index_port.write(0x03);
    let a = crtc_data_port.read();
    crtc_data_port.write(a | 0x80);
    regs.crtc[0x03] |= 0x80;

    crtc_index_port.write(0x11);
    let a = crtc_data_port.read();
    crtc_data_port.write(a & !0x80);
    regs.crtc[0x11] &= !0x80;

    for (i, &crtc) in regs.crtc.iter().enumerate() {
        crtc_index_port.write(i as u8);
        crtc_data_port.write(crtc);
    }

    // Write GC registers
    let mut gc_index_port = Port::new(VGA_GC_INDEX);
    let mut gc_data_port = Port::new(VGA_GC_DATA);
    for (i, &gc) in regs.gc.iter().enumerate() {
        gc_index_port.write(i as u8);
        gc_data_port.write(gc);
    }

    let mut instat_read_port = Port::new(VGA_INSTAT_READ);
    let mut ac_index_port = Port::new(VGA_AC_INDEX);
    let mut ac_write_port = Port::new(VGA_AC_WRITE);
    let _ = instat_read_port.read();
    for (i, &ac) in regs.ac.iter().enumerate() {
        ac_index_port.write(i as u8);
        ac_write_port.write(ac);
    }
    let _ = instat_read_port.read();
    ac_index_port.write(0x20);

    // Write the palette to the DAC
    Port::new(VGA_DAC_MASK).write(0xFF);
}

struct Regs {
    misc: u8,
    seq: [u8; VGA_NUM_SEQ_REGS],
    crtc: [u8; VGA_NUM_CRTC_REGS],
    gc: [u8; VGA_NUM_GC_REGS],
    ac: [u8; VGA_NUM_AC_REGS],
}

impl Regs {
    const fn graphic_regs() -> Regs {
        Regs {
            misc: 0x63,
            seq: [0x03, 0x01, 0x0F, 0x00, 0x0E],
            crtc: [
                0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x9C, 0x0E, 0x8F, 0x28, 0x40, 0x96, 0xB9, 0xA3, 0xFF,
            ],
            gc: [0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF],
            ac: [
                0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
                0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00, 0x00,
            ],
        }
    }

    const fn text_regs() -> Regs {
        Regs {
            misc: 0x67,
            seq: [0x03, 0x00, 0x03, 0x00, 0x02],
            crtc: [
                0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F, 0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00,
                0x00, 0x50, 0x9C, 0x0E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xA3, 0xFF,
            ],
            gc: [0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00, 0xFF],
            ac: [
                0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D,
                0x3E, 0x3F, 0x0C, 0x00, 0x0F, 0x08, 0x00,
            ],
        }
    }
}
